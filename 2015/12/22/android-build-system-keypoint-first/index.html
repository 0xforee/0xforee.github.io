<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="baidu-site-verification" content="codeva-4pzb7QQt07"><title>Android编译系统分析之几个关键点（一） - 0xforee&#039;s blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="0xforee&#039;s blog"><meta name="msapplication-TileImage" content="/img/fav_icon.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="0xforee&#039;s blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="以下这段代码就是解析AndroidProducts.mk以及其内容的关键代码"><meta property="og:type" content="blog"><meta property="og:title" content="Android编译系统分析之几个关键点（一）"><meta property="og:url" content="http://www.0xforee.top/2015/12/22/android-build-system-keypoint-first/"><meta property="og:site_name" content="0xforee&#039;s blog"><meta property="og:description" content="以下这段代码就是解析AndroidProducts.mk以及其内容的关键代码"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://www.0xforee.top/img/og_image.png"><meta property="article:published_time" content="2015-12-22T15:22:19.000Z"><meta property="article:modified_time" content="2015-12-22T15:45:45.000Z"><meta property="article:author" content="0xforee"><meta property="article:tag" content="android"><meta property="article:tag" content="build"><meta property="article:tag" content="makefile"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="http://www.0xforee.top/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://www.0xforee.top/2015/12/22/android-build-system-keypoint-first/"},"headline":"Android编译系统分析之几个关键点（一）","image":["http://www.0xforee.top/img/og_image.png"],"datePublished":"2015-12-22T15:22:19.000Z","dateModified":"2015-12-22T15:45:45.000Z","author":{"@type":"Person","name":"0xforee"},"publisher":{"@type":"Organization","name":"0xforee's blog","logo":{"@type":"ImageObject"}},"description":"以下这段代码就是解析AndroidProducts.mk以及其内容的关键代码"}</script><link rel="canonical" href="http://www.0xforee.top/2015/12/22/android-build-system-keypoint-first/"><link rel="icon" href="/img/fav_icon.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><script>var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?8e6bb145a6bd99001a8efd90754c2fb0";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();</script><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><script src="https://www.googletagmanager.com/gtag/js?id=G-W64LLZYFJX" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
    
        gtag('config', 'G-W64LLZYFJX');</script><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="0xforee's blog" type="application/atom+xml">
</head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">0xforee&#039;s blog</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/archives">时间轴</a><a class="navbar-item" href="/categories">栏目</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-9-tablet is-9-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><h1 class="title is-3 is-size-4-mobile">Android编译系统分析之几个关键点（一）</h1><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2015-12-22T15:22:19.000Z" title="12/22/2015, 11:22:19 PM">2015-12-22</time></span><span class="level-item"><a class="link-muted" href="/categories/Android%E7%BC%96%E8%AF%91%E7%B3%BB%E7%BB%9F%E8%A7%A3%E6%9E%90/">Android编译系统解析</a></span><span class="level-item">42 分钟读完 (大约6278个字)</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>次访问</span></div></div><div class="content"><p><strong>Android 编译系统解析系列文档</strong></p>
<p>编译系统入口envsetup.sh解析</p>
<ul>
<li><a href="https://www.0xforee.top/2015/11/05/android-build-system-envsetup/">source build&#x2F;envsetup.sh 做了什么？</a></li>
</ul>
<p>解析lunch的执行过程以及make执行过程中include文件的顺序</p>
<ul>
<li><a href="https://www.0xforee.top/2015/12/01/android-build-system-lunch/">Android编译系统分析之lunch分析</a></li>
<li><a href="https://www.0xforee.top/2015/12/08/android-build-system-make/">Android编译系统分析之make分析</a></li>
</ul>
<p>关注一些make执行过程中的几个关键点</p>
<ul>
<li><a href="https://www.0xforee.top/2015/12/22/android-build-system-keypoint-first/">Android编译系统分析之几个关键点（一）</a></li>
<li><a href="https://www.0xforee.top/2015/12/28/android-build-system-keypoint-second/">Android编译系统分析之几个关键点（二）</a></li>
<li><a href="https://www.0xforee.top/2016/01/08/android-build-systemui-keypoint-third/">Android编译系统分析之几个关键点（三）</a></li>
</ul>
<p>对一些独特的语法结构进行解析</p>
<ul>
<li><a href="https://www.0xforee.top/2016/02/24/android-build-system-parse-PRODUCT_COPY_FILES/">PRODUCT_COPY_FILES语法解析</a></li>
<li><a href="https://www.0xforee.top/2016/03/29/android-build-system-parse-PRODUCT_PROPERTY_OVERRIDES/">关于PRODUCT_PROPERTY_OVERRIDES属性的解析</a></li>
</ul>
<hr>
<p>我们首先来看看今天的主角，以下这段代码就是解析AndroidProducts.mk以及其内容的关键代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">###################</span><br><span class="line">build/core/product_config.mk</span><br><span class="line">###################</span><br><span class="line"></span><br><span class="line">ifneq ($(strip $(TARGET_BUILD_APPS)),)</span><br><span class="line"># An unbundled app build needs only the core product makefiles.</span><br><span class="line">all_product_configs := $(call get-product-makefiles,\</span><br><span class="line">    $(SRC_TARGET_DIR)/product/AndroidProducts.mk)</span><br><span class="line">else</span><br><span class="line"># Read in all of the product definitions specified by the AndroidProducts.mk</span><br><span class="line"># files in the tree.</span><br><span class="line">all_product_configs := $(get-all-product-makefiles)</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line"># Find the product config makefile for the current product.</span><br><span class="line"># all_product_configs consists items like:</span><br><span class="line"># &lt;product_name&gt;:&lt;path_to_the_product_makefile&gt;</span><br><span class="line"># or just &lt;path_to_the_product_makefile&gt; in case the product name is the</span><br><span class="line"># same as the base filename of the product config makefile.</span><br><span class="line">current_product_makefile :=</span><br><span class="line">all_product_makefiles :=</span><br><span class="line">$(foreach f, $(all_product_configs),\</span><br><span class="line">    $(eval _cpm_words := $(subst :,$(space),$(f)))\</span><br><span class="line">    $(eval _cpm_word1 := $(word 1,$(_cpm_words)))\</span><br><span class="line">    $(eval _cpm_word2 := $(word 2,$(_cpm_words)))\</span><br><span class="line">    $(if $(_cpm_word2),\</span><br><span class="line">        $(eval all_product_makefiles += $(_cpm_word2))\</span><br><span class="line">        $(if $(filter $(TARGET_PRODUCT),$(_cpm_word1)),\</span><br><span class="line">            $(eval current_product_makefile += $(_cpm_word2)),),\</span><br><span class="line">        $(eval all_product_makefiles += $(f))\</span><br><span class="line">        $(if $(filter $(TARGET_PRODUCT),$(basename $(notdir $(f)))),\</span><br><span class="line">            $(eval current_product_makefile += $(f)),)))</span><br><span class="line">_cpm_words :=</span><br><span class="line">_cpm_word1 :=</span><br><span class="line">_cpm_word2 :=</span><br><span class="line">current_product_makefile := $(strip $(current_product_makefile))</span><br><span class="line">all_product_makefiles := $(strip $(all_product_makefiles))</span><br><span class="line"></span><br><span class="line">ifneq (,$(filter product-graph dump-products, $(MAKECMDGOALS)))</span><br><span class="line"># Import all product makefiles.</span><br><span class="line">$(call import-products, $(all_product_makefiles))</span><br><span class="line">else</span><br><span class="line"># Import just the current product.</span><br><span class="line">ifndef current_product_makefile</span><br><span class="line">$(error Can not locate config makefile for product &quot;$(TARGET_PRODUCT)&quot;)</span><br><span class="line">endif</span><br><span class="line">ifneq (1,$(words $(current_product_makefile)))</span><br><span class="line">$(error Product &quot;$(TARGET_PRODUCT)&quot; ambiguous: matches $(current_product_makefile))</span><br><span class="line">endif</span><br><span class="line">$(call import-products, $(current_product_makefile))</span><br><span class="line">endif  # Import all or just the current product makefile</span><br><span class="line"></span><br><span class="line"># Sanity check</span><br><span class="line">$(check-all-products)</span><br><span class="line"></span><br><span class="line">ifneq ($(filter dump-products, $(MAKECMDGOALS)),)</span><br><span class="line">$(dump-products)</span><br><span class="line">$(error done)</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line"># Convert a short name like &quot;sooner&quot; into the path to the product</span><br><span class="line"># file defining that product.</span><br><span class="line">#</span><br><span class="line">INTERNAL_PRODUCT := $(call resolve-short-product-name, $(TARGET_PRODUCT))</span><br><span class="line">ifneq ($(current_product_makefile),$(INTERNAL_PRODUCT))</span><br><span class="line">$(error PRODUCT_NAME inconsistent in $(current_product_makefile) and $(INTERNAL_PRODUCT))</span><br><span class="line">endif</span><br><span class="line">current_product_makefile :=</span><br><span class="line">all_product_makefiles :=</span><br><span class="line">all_product_configs :=</span><br></pre></td></tr></table></figure>

<h3 id="该加载哪里的AndroidProducts-mk文件？"><a href="#该加载哪里的AndroidProducts-mk文件？" class="headerlink" title="该加载哪里的AndroidProducts.mk文件？"></a>该加载哪里的AndroidProducts.mk文件？</h3><p>我们将之前的代码拆着来看，首先看AndroidProducts.mk文件是如何被加载到Android整个编译环境中的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">###################</span><br><span class="line">build/core/product_config.mk</span><br><span class="line">###################</span><br><span class="line"></span><br><span class="line">ifneq ($(strip $(TARGET_BUILD_APPS)),)</span><br><span class="line"># An unbundled app build needs only the core product makefiles.</span><br><span class="line">all_product_configs := $(call get-product-makefiles,\</span><br><span class="line">    $(SRC_TARGET_DIR)/product/AndroidProducts.mk)</span><br><span class="line">else</span><br><span class="line"># Read in all of the product definitions specified by the AndroidProducts.mk</span><br><span class="line"># files in the tree.</span><br><span class="line">all_product_configs := $(get-all-product-makefiles)</span><br><span class="line">endif</span><br></pre></td></tr></table></figure>
<p>这里判断构建的目标是不是APP，对于独立APP的编译，只需要加载核心目录下（build&#x2F;target&#x2F;product）AndroidProducts.mk文件即可，如果是构建整个系统,那么需要加载所有的AndroidProducts.mk文件  </p>
<p><code>TARGET_BUILD_APPS</code>这个变量可以通过<code>tapas</code>命令指定（具体命令使用方式请参见envsetup.sh），也可以通过”APP-&lt;appname&gt;” 来指定  </p>
<p>这个变量默认为空，也就是编译整个系统，我们可以在加载环境变量之后通过使用printconfig命令来查看我们是否设置过<code>TARGET_BUILD_APPS</code>变量  </p>
<h3 id="取得编译系统中所有的AndroidProducts-mk"><a href="#取得编译系统中所有的AndroidProducts-mk" class="headerlink" title="取得编译系统中所有的AndroidProducts.mk"></a>取得编译系统中所有的AndroidProducts.mk</h3><p><code>get-all-product-makefiles</code>函数定义在build&#x2F;core&#x2F;product.mk文件中，是<code>get-product-makefiles</code>的一个简单的封装</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">####################</span><br><span class="line">build/core/product.mk</span><br><span class="line">####################</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># Returns the sorted concatenation of all PRODUCT_MAKEFILES</span><br><span class="line"># variables set in all AndroidProducts.mk files.</span><br><span class="line"># $(call ) isn&#x27;t necessary.</span><br><span class="line">#</span><br><span class="line">define get-all-product-makefiles</span><br><span class="line">$(call get-product-makefiles,$(_find-android-products-files))</span><br><span class="line">endef</span><br></pre></td></tr></table></figure>
<p>其中的<code>_find-android-products-files</code>函数返回的是整个编译系统中所有AndroidProducts.mk的集合</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">####################</span><br><span class="line">build/core/product.mk</span><br><span class="line">####################</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># Returns the list of all AndroidProducts.mk files.</span><br><span class="line"># $(call ) isn&#x27;t necessary.</span><br><span class="line">#</span><br><span class="line">define _find-android-products-files</span><br><span class="line">$(shell test -d device &amp;&amp; find device -maxdepth 6 -name AndroidProducts.mk) \</span><br><span class="line">  $(shell test -d vendor &amp;&amp; find vendor -maxdepth 6 -name AndroidProducts.mk) \</span><br><span class="line">  $(SRC_TARGET_DIR)/product/AndroidProducts.mk</span><br><span class="line">endef</span><br></pre></td></tr></table></figure>
<p>如上：扫描device与vendor目录下6层深度的子目录下的所有AndroidProducts.mk文件，以及build&#x2F;target&#x2F;product&#x2F;AndroidProducts.mk文件，从这里我们可以看出，这里的得到的最后结果带有相对于源码根目录的相对路径，类似以下格式：</p>
<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">device/htc/flounder/AndroidProducts.mk</span><br><span class="line">device/meizu/m86/AndroidProducts.mk</span><br><span class="line">device/samsung/avl7420/AndroidProducts.mk</span><br><span class="line"></span><br><span class="line">....</span><br><span class="line"></span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">&gt; **注：**`SRC_TARGET_DIR=build/target`  </span><br><span class="line"></span><br><span class="line">### 处理AndroidProducts.mk</span><br><span class="line">接下来要对扫描出的AndroidProducts.mk文件进行处理</span><br><span class="line"></span><br><span class="line">```makefile?linenums=<span class="number">41</span></span><br><span class="line">####################</span><br><span class="line">build/core/product.mk</span><br><span class="line">####################</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># Returns the sorted concatenation <span class="keyword">of</span> PRODUCT_MAKEFILES</span><br><span class="line"># variables set <span class="keyword">in</span> the given AndroidProducts.mk files.</span><br><span class="line"># $(<span class="number">1</span>): the list <span class="keyword">of</span> AndroidProducts.mk files.</span><br><span class="line">#</span><br><span class="line">define get-product-makefiles</span><br><span class="line">$(sort \</span><br><span class="line">  $(foreach f,$(<span class="number">1</span>), \</span><br><span class="line">    $(eval PRODUCT_MAKEFILES :=) \</span><br><span class="line">    $(eval LOCAL_DIR := $(patsubst %/,%,$(dir $(f)))) \</span><br><span class="line">    $(eval include $(f)) \</span><br><span class="line">    $(PRODUCT_MAKEFILES) \</span><br><span class="line">   ) \</span><br><span class="line">  $(eval PRODUCT_MAKEFILES :=) \</span><br><span class="line">  $(eval LOCAL_DIR :=) \</span><br><span class="line"> )</span><br><span class="line">endef</span><br></pre></td></tr></table></figure>
<p>我们注意到以上代码有一行是对<code>LOCAL_DIR</code>进行了定义，这个定义的原因是因为AndroidProducts.mk文件中定义的格式像下边这样：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(TARGET_PRODUCT)</span>,meizu_m86)</span><br><span class="line">    PRODUCT_MAKEFILES := <span class="variable">$(LOCAL_DIR)</span>/meizu_m86.mk</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure>
<p>我们还记得上边扫描得出的所有AndroidProducts.mk的集合是带有相对路径的，所以我们这里可以通过<code>dir</code>获取路径，然后置换为下一行include对应AndroidProducts.mk中的<code>LOCAL_DIR</code>，这样我们就得到了我们真正要加载的makefile文件，就是我们配置一个device需要用到的文件（例：meizu_m86.mk）</p>
<p>这样在将所有的AndroidProducts.mk文件中的内容解析完毕之后，我们就得到了一份使用sort排序并去重的product_makefile文件列表  </p>
<blockquote>
<p><strong>注意：</strong> 这里我们并未区分我们要编译的<code>product_makefile</code>，也就是说这是一个包含全部<code>product_makefile</code>的列表</p>
</blockquote>
<h3 id="取得current-makefile（当前lunch机型的配置文件）"><a href="#取得current-makefile（当前lunch机型的配置文件）" class="headerlink" title="取得current_makefile（当前lunch机型的配置文件）"></a>取得current_makefile（当前lunch机型的配置文件）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">###################</span><br><span class="line">build/core/product_config.mk</span><br><span class="line">###################</span><br><span class="line"></span><br><span class="line">current_product_makefile :=</span><br><span class="line">all_product_makefiles :=</span><br><span class="line">$(foreach f, $(all_product_configs),\</span><br><span class="line">    $(eval _cpm_words := $(subst :,$(space),$(f)))\</span><br><span class="line">    $(eval _cpm_word1 := $(word 1,$(_cpm_words)))\</span><br><span class="line">    $(eval _cpm_word2 := $(word 2,$(_cpm_words)))\</span><br><span class="line">    $(if $(_cpm_word2),\</span><br><span class="line">    #then-1</span><br><span class="line">        $(eval all_product_makefiles += $(_cpm_word2))\</span><br><span class="line">        $(if $(filter $(TARGET_PRODUCT),$(_cpm_word1)),\</span><br><span class="line">        #then-2</span><br><span class="line">            $(eval current_product_makefile += $(_cpm_word2)),),\</span><br><span class="line">    #else  </span><br><span class="line">        $(eval all_product_makefiles += $(f))\</span><br><span class="line">        $(if $(filter $(TARGET_PRODUCT),$(basename $(notdir $(f)))),\</span><br><span class="line">        #then-3</span><br><span class="line">            $(eval current_product_makefile += $(f)),)))</span><br><span class="line">_cpm_words :=</span><br><span class="line">_cpm_word1 :=</span><br><span class="line">_cpm_word2 :=</span><br><span class="line">current_product_makefile := $(strip $(current_product_makefile))</span><br><span class="line">all_product_makefiles := $(strip $(all_product_makefiles))</span><br></pre></td></tr></table></figure>
<p>关于makefile中IF的语法:<br><code>$(if &lt;condition&gt;, &lt;then-part&gt;, &lt;else-part&gt; )</code>  </p>
<p>从前边的代码我们可以知道all_product_configs是代表device以及vendor所有的AndroidProducts.mk文件中变量<code>PRODUCT_MAKEFILES</code>的值的集合，这个<code>PRODUCT_MAKEFILES</code>值包括两种情况</p>
<ol>
<li><code>&lt;product_name&gt;:&lt;path_to_the_product_makefile&gt;</code></li>
<li><code>&lt;path_to_the_product_makefile&gt;</code></li>
</ol>
<p>也就是在上边代码中&#x3D;&#x3D;then-1&#x3D;&#x3D;做出判断，我们一般都是使用的第二种情况，所以我们就解析一下else的情况，else主要做了两步处理</p>
<ol>
<li>将所有的product_makefile文件加入到<code>all_product_makefiles</code>变量中</li>
<li>通过TARGET_PRODUCT来解析出对应的product_makefile文件</li>
</ol>
<p>通过以上两步，我们可以得到一个包含全部device，vendor下的product_makefile文件的变量<code>all_product_makefiles</code>以及当前我们需要编译的product_makefile的变量<code>current_product_makeifle</code></p>
<blockquote>
<p><strong>以上的示例也提醒我们,AndroidProducts.mk文件内容中指向的product_makefile名称必须标准</strong></p>
</blockquote>
<h3 id="导入PRODUCT变量"><a href="#导入PRODUCT变量" class="headerlink" title="导入PRODUCT变量"></a>导入PRODUCT变量</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">###################</span><br><span class="line">build/core/product_config.mk</span><br><span class="line">###################</span><br><span class="line"></span><br><span class="line">ifneq (,$(filter product-graph dump-products, $(MAKECMDGOALS)))</span><br><span class="line"># Import all product makefiles.</span><br><span class="line">$(call import-products, $(all_product_makefiles))</span><br><span class="line">else</span><br><span class="line"># Import just the current product.</span><br><span class="line">ifndef current_product_makefile</span><br><span class="line">$(error Can not locate config makefile for product &quot;$(TARGET_PRODUCT)&quot;)</span><br><span class="line">endif</span><br><span class="line">ifneq (1,$(words $(current_product_makefile)))</span><br><span class="line">$(error Product &quot;$(TARGET_PRODUCT)&quot; ambiguous: matches $(current_product_makefile))</span><br><span class="line">endif</span><br><span class="line">$(call import-products, $(current_product_makefile))</span><br><span class="line">endif  # Import all or just the current product makefile</span><br><span class="line"></span><br><span class="line"># Sanity check</span><br><span class="line">$(check-all-products)</span><br><span class="line"></span><br><span class="line">ifneq ($(filter dump-products, $(MAKECMDGOALS)),)</span><br><span class="line">$(dump-products)</span><br><span class="line">$(error done)</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line"># Convert a short name like &quot;sooner&quot; into the path to the product</span><br><span class="line"># file defining that product.</span><br><span class="line">#</span><br><span class="line">INTERNAL_PRODUCT := $(call resolve-short-product-name, $(TARGET_PRODUCT))</span><br><span class="line">ifneq ($(current_product_makefile),$(INTERNAL_PRODUCT))</span><br><span class="line">$(error PRODUCT_NAME inconsistent in $(current_product_makefile) and $(INTERNAL_PRODUCT))</span><br><span class="line">endif</span><br></pre></td></tr></table></figure>
<p>在上边所示的代码中，google也给出了调试product_makefile的方式：</p>
<ol>
<li><code>MAKECMDGOALS</code>中如果包含<code>dump-products</code>，那么执行<code>$(dump-products)</code>命令打印所有的<code>PRODUCT_XXXX</code>变量，具体规则定义位于<code>build/core/product.mk</code>文件</li>
<li><code>MAKECMDGOALS</code>中如果包含<code>product-graph</code>，那么google会在out目录生成一个pdf和svg文件，这两个文件内包含了所有的product_makefile文件之间的相互依赖关系，具体规则定义位于<code>build/core/tasks/product-graph.mk</code></li>
</ol>
<p>一般的编译来说，是调用<code>import-products</code>导入当前的我们要编译的机型配置，也就是这个<code>current_product_makefile</code>这个变量的值  </p>
<blockquote>
<p><strong>注意</strong>：<code>current_product_makefile</code>这个值是<strong>唯一</strong>的，否则会报错</p>
</blockquote>
<blockquote>
<p><strong>重要说明：</strong><br>对于各个目录下定义的<code>PRODUCT_</code>开头的相同的变量都会在<code>import-products</code>中得到处理（或者说展开），在处理完毕之后，对于各个变量的获取，我们都可以在如下格式的变量中获取到<br><code>PRODUCTS.$(INTERNAL_PRODUCT).PRODUCT_XXXX</code>  </p>
<ul>
<li>其中<code>INTERNAL_PRODUCT</code>值为上边<code>current_product_makefile</code>的值，类似<code>device/meizu/m86/meizu_m86.mk</code>  </li>
<li><code>PRODUCT_XXXXX</code>表示<code>PRODUCT_COPY_FILES</code>，<code>PRODUCT_LOCALES</code>等变量</li>
</ul>
</blockquote>
<p>让我们接着来看看<code>import-products</code>干了什么</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">####################</span><br><span class="line">build/core/product.mk</span><br><span class="line">####################</span><br><span class="line"></span><br><span class="line">define import-products</span><br><span class="line">    $(call import-nodes,PRODUCTS,$(1),$(_product_var_list))</span><br><span class="line">endef</span><br></pre></td></tr></table></figure>
<p>我们记录一下传入的参数：<code>$(1) = $(current_product_makefile)</code>  </p>
<p>实际调用<code>import-nodes</code>导入传入的参数，这里的<code>_product_var_list</code>是以PRODUCT开头的一系列的变量的枚举</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">####################</span><br><span class="line">build/core/product.mk</span><br><span class="line">####################</span><br><span class="line"></span><br><span class="line">_product_var_list := \</span><br><span class="line">    PRODUCT_NAME \</span><br><span class="line">    PRODUCT_MODEL \</span><br><span class="line">    PRODUCT_LOCALES \</span><br><span class="line">    PRODUCT_AAPT_CONFIG \</span><br><span class="line">    PRODUCT_AAPT_PREF_CONFIG \</span><br><span class="line">    PRODUCT_AAPT_PREBUILT_DPI \</span><br><span class="line">    PRODUCT_PACKAGES \</span><br><span class="line">    PRODUCT_PACKAGES_DEBUG \</span><br><span class="line">    PRODUCT_PACKAGES_ENG \</span><br><span class="line">    PRODUCT_PACKAGES_TESTS \</span><br><span class="line">    PRODUCT_DEVICE \</span><br><span class="line">    PRODUCT_MANUFACTURER \</span><br><span class="line">    PRODUCT_BRAND \</span><br><span class="line">    PRODUCT_PROPERTY_OVERRIDES \</span><br><span class="line">    PRODUCT_DEFAULT_PROPERTY_OVERRIDES \</span><br><span class="line">    PRODUCT_CHARACTERISTICS \</span><br><span class="line">    PRODUCT_COPY_FILES \</span><br><span class="line">    PRODUCT_OTA_PUBLIC_KEYS \</span><br><span class="line">    PRODUCT_EXTRA_RECOVERY_KEYS \</span><br><span class="line">    PRODUCT_PACKAGE_OVERLAYS \</span><br><span class="line">    DEVICE_PACKAGE_OVERLAYS \</span><br><span class="line">    PRODUCT_TAGS \</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">我们再来看看`import-nodes`这个函数干了什么</span><br><span class="line"></span><br><span class="line">```makefile?linenums=241</span><br><span class="line">####################</span><br><span class="line">build/core/node_fns.mk</span><br><span class="line">####################</span><br><span class="line">#</span><br><span class="line"># $(1): output list variable name, like &quot;PRODUCTS&quot; or &quot;DEVICES&quot;</span><br><span class="line"># $(2): list of makefiles representing nodes to import</span><br><span class="line"># $(3): list of node variable names</span><br><span class="line">#</span><br><span class="line"></span><br><span class="line">define import-nodes</span><br><span class="line">$(if \</span><br><span class="line">  $(foreach _in,$(2), \</span><br><span class="line">    $(eval _node_import_context := &gt;&gt;==_nic.$(1).[[$(_in)]]==&lt;&lt;) \</span><br><span class="line">    # _node_import_context := _nic.PRODUCT.[[device/meizu/m86/meizu_m86.mk]]#</span><br><span class="line">    $(if $(_include_stack),$(eval $(error ASSERTION FAILED: _include_stack \</span><br><span class="line">                should be empty here: $(_include_stack))),) \</span><br><span class="line">    $(eval _include_stack := ) \</span><br><span class="line">    $(call &gt;&gt;==_import-nodes-inner,$(_node_import_context),$(_in),$(3)==&lt;&lt;) \</span><br><span class="line">    $(call move-var-list,$(_node_import_context).$(_in),$(1).$(_in),$(3)) \</span><br><span class="line">    $(eval _node_import_context :=) \</span><br><span class="line">    $(eval $(1) := $($(1)) $(_in)) \</span><br><span class="line">    $(if $(_include_stack),$(eval $(error ASSERTION FAILED: _include_stack \</span><br><span class="line">                should be empty here: $(_include_stack))),) \</span><br><span class="line">   ) \</span><br><span class="line">,)</span><br><span class="line">endef</span><br></pre></td></tr></table></figure>
<p><code>import-nodes</code>函数主要做了以下几件事：</p>
<ul>
<li>以<code>current_product_makefile</code>定义了一个变量，这个变量的作用其实就是用来标示唯一性的，在后边的代码中会将这个变量当前缀使用</li>
<li>使用<code>_import-nodes-inner</code>函数做具体的解析工作</li>
<li>将上一步解析完毕的变量变换前缀</li>
<li>将解析过的<code>current_product_makefile</code>都添加到PRODUCTS变量中</li>
</ul>
<blockquote>
<p><strong>重要提示</strong><br><code>move-var-list </code>用法很简单：<br><code>$(call move-var-list,SRC,DST,A B)</code>：变更A和B的前缀SRC到DST  </p>
</blockquote>
<p>我们之前提到过，在所有的PRODUCT_XXXX变量都展开之后，也就是<code>import-products current_product_makefile</code>之后，所有的PRODUCT_XXXX变量都会被集中到以<code>PRODUCTS.$(INTERNAL_PRODUCT)</code>为前缀的对应的变量中，这个操作就是使用<code>move-var-list</code>来完成的  </p>
<p>下边是<code>_import-nodes-innner</code>函数中将要使用到的变量的列表表示：</p>
<table>
<thead>
<tr>
<th>$(_node_import_context)</th>
<th>$(_in)</th>
<th>$(3)</th>
<th>$(2)</th>
<th>$(1)</th>
</tr>
</thead>
<tbody><tr>
<td>_nic.PRODUCTS.[[device&#x2F;meizu&#x2F;m86&#x2F;meizu_m86.mk]]</td>
<td>device&#x2F;meizu&#x2F;m86&#x2F;meizu_m86.mk</td>
<td>$(_product_var_list)</td>
<td>device&#x2F;meizu&#x2F;m86&#x2F;meizu_m86.mk</td>
<td>PRODUCTS</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>重要提示</strong></p>
<ul>
<li>对于<code>$(_node_import_context)</code>所代表的内容为了方便叙述，我们定义为<strong>公有前缀</strong>，对于每次编译的目标，公有的前缀是唯一的</li>
<li>对于<code>$(_in)</code>或者<code>$(2)</code>中表示的内容，我们定义为<strong>私有前缀</strong>，对于同一编译目标不同makefile文件中的相同PRODUCT_XXX变量，我们都会使用<strong>公有前缀+私有前缀</strong>作为前缀来区分</li>
</ul>
</blockquote>
<p>我们继续来看</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">####################</span><br><span class="line">build/core/node_fns.mk</span><br><span class="line">####################</span><br><span class="line">#</span><br><span class="line"># $(1): context prefix</span><br><span class="line"># $(2): list of makefiles representing nodes to import</span><br><span class="line"># $(3): list of node variable names</span><br><span class="line">#</span><br><span class="line"></span><br><span class="line">define _import-nodes-inner</span><br><span class="line">  $(foreach _in,$(2), \</span><br><span class="line">    $(if $(wildcard $(_in)), \</span><br><span class="line">      $(if &gt;&gt;==$($(1).$(_in).seen==&lt;&lt;), \</span><br><span class="line">        $(eval ### &quot;skipping already-imported $(_in)&quot;) \</span><br><span class="line">       , \</span><br><span class="line">        $(eval $(1).$(_in).seen := true) \</span><br><span class="line">        $(call &gt;&gt;==_import-node,$(1),$(strip $(_in)),$(3)==&lt;&lt;) \</span><br><span class="line">       ) \</span><br><span class="line">     , \</span><br><span class="line">      $(error $(1): &quot;$(_in)&quot; does not exist) \</span><br><span class="line">     ) \</span><br><span class="line">   )</span><br><span class="line">endef</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>重要提示</strong></p>
<ul>
<li><code>wildcard</code>是一个通配符的关键字，这里用来判断$(_in)文件是否存在  </li>
<li>这里我们看到有一个foreach循环，这个在第一次的时候因为参数之后current_product_makefile，所以不会用到，后边我们在用到继承性的时候，因为会有继承多个product的情况发生，所以需要foreach这个函数来遍历</li>
</ul>
</blockquote>
<p>这里会有一个变量（<code>$(1).$(_in).seen</code>）来标示文件的内容是否已经导入，以86为例，变量以及内容分别为  </p>
<table>
<thead>
<tr>
<th>$(1)</th>
<th>$(_in)</th>
<th>$(3)</th>
</tr>
</thead>
<tbody><tr>
<td>_nic.PRODUCTS.[[device&#x2F;meizu&#x2F;m86&#x2F;meizu_m86.mk]]</td>
<td>device&#x2F;meizu&#x2F;m86&#x2F;meizu_m86.mk</td>
<td>_product_var_list</td>
</tr>
</tbody></table>
<p>很长很变态…..  </p>
<p><code>_import-nodes-inner</code>函数只是来判断是否导入过文件，如果没有导入，使用<code>_import_node</code>来实际导入  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">####################</span><br><span class="line">build/core/node_fns.mk</span><br><span class="line">####################</span><br><span class="line">#</span><br><span class="line"># $(1): context prefix</span><br><span class="line"># $(2): makefile representing this node</span><br><span class="line"># $(3): list of node variable names</span><br><span class="line">#</span><br><span class="line"># _include_stack contains the list of included files, with the most recent files first.</span><br><span class="line"></span><br><span class="line">define _import-node</span><br><span class="line">  $(eval _include_stack := $(2) $$(_include_stack))</span><br><span class="line">  $(call clear-var-list, $(3))</span><br><span class="line">  $(eval LOCAL_PATH := $(patsubst %/,%,$(dir $(2))))</span><br><span class="line">  $(eval MAKEFILE_LIST :=)</span><br><span class="line">  $(eval &gt;&gt;==include $(2)==&lt;&lt;)</span><br><span class="line">  $(eval _included := $(filter-out $(2),$(MAKEFILE_LIST)))</span><br><span class="line">  $(eval MAKEFILE_LIST :=)</span><br><span class="line">  $(eval LOCAL_PATH :=)</span><br><span class="line">  $(call copy-var-list, $(1).$(2), $(3))</span><br><span class="line">  $(call clear-var-list, $(3))</span><br><span class="line"></span><br><span class="line">  $(eval $(1).$(2).inherited := \</span><br><span class="line">      $(call &gt;&gt;==get-inherited-nodes,$(1).$(2),$(3))==&lt;&lt;)</span><br><span class="line">  $(call &gt;&gt;==_import-nodes-inner,$(1),$($(1).$(2).inherited),$(3)==&lt;&lt;)</span><br><span class="line"></span><br><span class="line">  $(call &gt;&gt;==_expand-inherited-values,$(1),$(2),$(3)==&lt;&lt;)</span><br><span class="line"></span><br><span class="line">  $(eval $(1).$(2).inherited :=)</span><br><span class="line">  $(eval _include_stack := $(wordlist 2,9999,$$(_include_stack)))</span><br><span class="line">endef</span><br></pre></td></tr></table></figure>
<p><strong>知识点</strong><br><code>MAKEFILE_LIST</code>：<br>这个变量内容包含，在环境变量中指定的，命令行中指定的，以及make指定makefile文件时，使用include包含进的文件，这三者所组成的列表  </p>
<p><code>_import-node</code>函数主要做了以下几件事：</p>
<ol>
<li>将找到的最新文件入栈，此时栈应该是空的，也就是说meizu_m86.mk是第一个入栈的</li>
<li>清除所有的PRODUCT_开头的变量的值</li>
<li><strong>include meizu_m86.mk</strong> <code>meizu_m86.mk</code>是整个机型的配置入口，此处开始处理</li>
<li>将处理过的文件添加到_included变量中</li>
<li>将第三步include进来的文件中的PRODUCT_开头的变量使用<code>copy-var-list</code>函数添加$(1).$(２)前缀，这里就是<strong>公有前缀+私有前缀</strong></li>
<li>取得带有@inherit前缀的变量，然后去掉@inherit前缀，然后排序去重，获得继承第一层的makefile文件的列表，记录到<code>公有前缀+私有前缀+inherited</code>变量中</li>
<li>通过<code>_import-nodes-inner</code>来循环获取上一步得到的继承列表，将所有层次的继承的文j件都获取到，最后得到一个解除@inherit前缀的包含所有继承层次的makefile文件列表</li>
<li><code>_expand_-inherited-values</code>展开上一步得到的这些文件中_product_var_list中变量的值</li>
<li>清空继承列表与_include_stack</li>
</ol>
<p>这里第1步到第7部，以及加上前边的<code>_import-nodes-inner</code>一起构成了递归，我们在递归展开这些变量的最后一步时，会调用<code>_expand-inherited-values</code>来从最深层次的继承一直展开到最浅层次的继承，也就是第一层继承，要明白最深层次与之后浅层次的makefile中变量的关系，是最深覆盖最浅？还是最浅覆盖最深？或者二者叠加？我们就需要看<code>_expand-inherited-values</code>的具体内容    </p>
<h3 id="什么是inherit？"><a href="#什么是inherit？" class="headerlink" title="什么是inherit？"></a>什么是inherit？</h3><p>在看最后一个函数的内容之前，我们还需要了解一个知识点，在第５步的时候，出现了一个新的概念inherit，也就是继承，我们经常会在product_makefile中看到<code>inherit-product</code>函数就是继承的一个典型的应用，我们先来看看它是怎么用的，然后再往下看具体的解析过程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">define inherit-product</span><br><span class="line">  $(foreach v,$(_product_var_list), \</span><br><span class="line">      $(eval $(v) := $($(v)) $(INHERIT_TAG)$(strip $(1)))) \</span><br><span class="line">  $(eval inherit_var := \</span><br><span class="line">      PRODUCTS.$(strip $(word 1,$(_include_stack))).INHERITS_FROM) \</span><br><span class="line">  $(eval $(inherit_var) := $(sort $($(inherit_var)) $(strip $(1)))) \</span><br><span class="line">  $(eval inherit_var:=) \</span><br><span class="line">  $(eval ALL_PRODUCTS := $(sort $(ALL_PRODUCTS) $(word 1,$(_include_stack))))</span><br><span class="line">endef</span><br></pre></td></tr></table></figure>
<p>这个函数在build&#x2F;core&#x2F;product.mk中定义，后边的参数都是跟一个makefile名称<br>示例：<br><code>$(call inherit-product, $(SRC_TARGET_DIR)/product/full_base.mk)</code>  </p>
<p>这个函数主要做了以下几件事：</p>
<ol>
<li>为_product_var_list中<strong>所有变量</strong>挨个加上<code>@inherit xxxmakefile</code>的前缀，这个xxxmakfile就是传入的$(1)变量值</li>
<li>组织当前正被处理（include）的文件内容的继承列表，具体是这样的：<ul>
<li>我们用<code>PRODUCTS.当前makefile.INHERITS_FROM</code>这个变量来存放当前makefile的继承列表</li>
<li>然后这个文件中的每一个使用<code>inherit-product</code>函数继承的makefile，都会被加到以上变量中<br>这一步的具体过程就是以下:<br><code>PRODUCTS.当前makefile.INHERITS_FORM :=$(sort $(PRODUCT.当前makefile.INHERITS_FROM) last_makefile )</code></li>
</ul>
</li>
<li>将当前正在处理（include）的makefile加入到变量ALL_PRODUCTS中</li>
</ol>
<p>了解了这个背景知识之后，我们可以得出以下几点：</p>
<ul>
<li>我们注意到之前分析的<code>_import-node</code>第三步有一个include product_makefile文件的操作，<strong>这里我们分析的<code>inherit-product</code>函数就在这个include的操作中被调用</strong></li>
<li>include操作是发生在<code>import-node</code>函数中，因此include的makefile也会被加入到_include_stack中</li>
<li>_product_var_list中的每个变量也都加入了带有@inherit前缀的所继承的xxxmakefile  </li>
<li><code>inherit-product</code>函数中还提供了一个INHERIT_FROM的变量，这个变量的相关用法，我们可以在<code>build/core/tasks/product-graph.mk</code>见到</li>
</ul>
<p>由以上内容得知，在这里我们只需要明白调用<code>inherit-product</code>函数只是添加了<code>@inherit:</code>这个前缀就行，当然从这里我们也可以看出，如果一个makefile文件中inherit两次同一个makefile，也会被在这里去重  </p>
<p>我们继续向下来看是如何解析加入@inherit前缀的这些变量</p>
<p><code>_get-inherited-nodes</code>的内容也很简单</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">define get-inherited-nodes</span><br><span class="line">$(sort \</span><br><span class="line">  $(subst $(INHERIT_TAG),, \</span><br><span class="line">    $(filter $(INHERIT_TAG)%, \</span><br><span class="line">      $(foreach v,$(2),$($(1).$(v))) \</span><br><span class="line"> )))</span><br><span class="line">endef</span><br></pre></td></tr></table></figure>
<ol>
<li>将_product_var_list中的变量挨个取出，这里的变量已经添加了前缀，因此要使用前缀取出，也就是类似_nic.PRODUCTS.[[device&#x2F;meizu&#x2F;m86&#x2F;meizu_m86.mk]].device&#x2F;meizu&#x2F;m86&#x2F;meizu_m86.mk所代表的product文件来取出var变量的值</li>
<li>过滤出带有@inherit前缀的变量值</li>
<li>将前缀去掉，然后排序去重，最后得到一份继承的makefile的list</li>
</ol>
<p>这个函数有点复杂，我们在这里说明一下：  </p>
<p>for循环之后，在_product_var_list中的全部变量(PRODUCT_LOCALES，PRODUCT_FILES等）中带有@inheri前缀的内容都会被取出来，然后去掉前缀，排序去重，我们之前解析过使用@inherit前缀的函数<code>inherit-product</code>，知道调用函数之后，所有的PRODUCT_XXX都会继承@inherite标识后边加入的makefile，因此，这一块的内容其实只是将我们之前include的makefile文件中所继承的（也就是调用inherit-product后的参数）所有makefile做了一个集合，你调用了几个inherit-product，也就有几个继承，这个函数的返回值最后是要记录在<code>公共前缀+私有前缀+inherited</code>这个变量中的，来表示某个makefile文件的继承性的</p>
<p>经过以上3步之后，我们可以（filter过滤出了带＠inherit前缀的变量，故变量原本的值没有在这个列表中）去除@inherit前缀的继承的makefile列表的集合，并且此集合是排序去重过的，这个集合被赋值给了<code>$(1).$(2).inherited</code>   </p>
<p>也就是之前我们说到的以makefile绝对路径来区分的前缀，然后又会重复调用<code>_import-nodes-inner</code>这个函数，这个函数我们已经解析过了，只是用来判断是否解析过传入的文件列表，实际将同样的参数传入了<code>_import-node</code>这个函数来进行解析  </p>
<p>总的来说<code>_import-node</code>与<code>_import-nodes-inner</code>与<code>get-inherited-nodes</code>在不停的循环，将每次<code>get-inherit-nodes</code>得到的去除了<code>@inherit</code>的makefile重新放入循环中，然后解析出这个makefile文件的所有的<code>_product_var_list</code>所对应的继承关系，将其中<code>_product_var_list</code>中的变量的值都加上某一前缀，这个前缀就是<code>_include_stack</code>栈中最近的一个makefile，因此不需要担心不同的makefile文件中的同一变量会互相覆盖，他们都会以不同的makefile作为前缀来标示</p>
<p>也就是在<code>_expand-inherited-values</code>函数之前，我们都会得到相如以下类型的变量：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_nic.PRODUCTS.<span class="string">[[device/meizu/m86/meizu_m86.mk]]</span>.last_makefile.PRODUCT_xxxx := aaa bbb @inherit xxxmakefile @inherit yyymakefile</span><br></pre></td></tr></table></figure>
<h3 id="展开继承的变量"><a href="#展开继承的变量" class="headerlink" title="展开继承的变量"></a>展开继承的变量</h3><p>我们来看最后一个函数<code>_expand-inherited-values</code>，我们将传入<code>_expand-inherited-values</code>的参数列举出来，方便后边查看</p>
<table>
<thead>
<tr>
<th>$(1)</th>
<th>$(2)</th>
<th>$(3)</th>
</tr>
</thead>
<tbody><tr>
<td>_nic.PRODUCTS.[[device&#x2F;meizu&#x2F;m86&#x2F;meizu_m86.mk]]</td>
<td>last_makefile</td>
<td>$(_product_var_list)</td>
</tr>
</tbody></table>
<p>假设，我们这里的$(2)，也就是last_makefile，是example.txt举例的最深层次的makefile文件，也就是<code>build/target/product/embedded.mk</code>文件，这个文件内容中已经不包含继承关系，因此<code>_get_inherited_nodes</code>返回的内容为空，<code>_import-node-inner</code>也什么都不做，我们可以直接看<code>_expand-inherited-values</code>  </p>
<p>仔细看传入的参数，其实就是传入<code>_import_node</code>的三个参数，其实就是公有前缀，私有前缀，以及一个PRODUCT_xxx的列表，我们可以用这三个参数组成我们调用<code>_expand-inherited-values</code>函数之前的那种类型的变量  </p>
<p>接下来我们来实际解析这个函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">define _expand-inherited-values</span><br><span class="line">  $(foreach v,$(3), \</span><br><span class="line">    $(eval ### &quot;Shorthand for the name of the target variable&quot;) \</span><br><span class="line">    $(eval _eiv_tv := $(1).$(2).$(v)) \</span><br><span class="line">    $(eval ### &quot;Get the list of nodes that this variable inherits&quot;) \</span><br><span class="line">    $(eval _eiv_i := \</span><br><span class="line">        $(sort \</span><br><span class="line">            $(patsubst $(INHERIT_TAG)%,%, \</span><br><span class="line">                $(filter $(INHERIT_TAG)%, $($(_eiv_tv)) \</span><br><span class="line">     )))) \</span><br><span class="line">    $(foreach i,$(_eiv_i), \</span><br><span class="line">      $(eval ### &quot;Make sure that this inherit appears only once&quot;) \</span><br><span class="line">      $(eval $(_eiv_tv) := \</span><br><span class="line">          $(call uniq-word,$($(_eiv_tv)),$(INHERIT_TAG)$(i))) \</span><br><span class="line">      $(eval ### &quot;Expand the inherit tag&quot;) \</span><br><span class="line">      $(eval $(_eiv_tv) := \</span><br><span class="line">          $(strip \</span><br><span class="line">              &gt;&gt;==$(patsubst $(INHERIT_TAG)$(i),$($(1).$(i).$(v)), \</span><br><span class="line">                  $($(_eiv_tv)))==&lt;&lt;)) \</span><br><span class="line">      $(eval ### &quot;Clear the child so DAGs don&#x27;t create duplicate entries&quot; ) \</span><br><span class="line">      $(eval $(1).$(i).$(v) :=) \</span><br><span class="line">      $(eval ### &quot;If we just inherited ourselves, it&#x27;s a cycle.&quot;) \</span><br><span class="line">      $(if $(filter $(INHERIT_TAG)$(2),$($(_eiv_tv))), \</span><br><span class="line">        $(warning Cycle detected between &quot;$(2)&quot; and &quot;$(i)&quot; for context &quot;$(1)&quot;) \</span><br><span class="line">        $(error import of &quot;$(2)&quot; failed) \</span><br><span class="line">      ) \</span><br><span class="line">     ) \</span><br><span class="line">   ) \</span><br><span class="line">   $(eval _eiv_tv :=) \</span><br><span class="line">   $(eval _eiv_i :=)</span><br><span class="line">endef</span><br></pre></td></tr></table></figure>
<p>这个函数做了以下几件事：</p>
<ol>
<li>_eiv_tv 将_product_var_list中的所有变量都添加了公有前缀＋私有前缀</li>
<li>_eiv_i 表示当前正在处理的makefile文件的继承关系makefile列表，是通过过滤@inherit这个前缀拿到的，显而易见，这个是从倒数第二深的makefile文件起作用，因为最深层次的makefile变量中不包含继承关系</li>
<li>使用<code>uniq-word</code>来确保只继承了一次，这种继承的检查发生在上层与紧挨着的下层之间</li>
<li>展开@inherit表示的变量，其实也就是使用比他深一层次的makefile文件的对应的PRODUCT_XXX变量替换@inherit这个标识符</li>
<li>检查是否循环继承（自己继承了自己）</li>
</ol>
<p>我们接着看<code>uniq-word</code>这个函数的实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">define uniq-word</span><br><span class="line">$(strip \</span><br><span class="line">  $(if $(filter-out 0 1,$(words $(filter $(2),$(1)))), \</span><br><span class="line">    $(eval h := |||$(subst $(space),|||,$(strip $(1)))|||) \</span><br><span class="line">    $(eval h := $(subst |||$(strip $(2))|||,|||$(space)|||,$(h))) \</span><br><span class="line">    $(eval h := $(word 1,$(h)) $(2) $(wordlist 2,9999,$(h))) \</span><br><span class="line">    $(subst |||,$(space),$(h)) \</span><br><span class="line">   , \</span><br><span class="line">    $(1) \</span><br><span class="line"> ))</span><br><span class="line">endef</span><br></pre></td></tr></table></figure>
<p>代码比较简单，读者可以根据前边的内容来分析这个函数的实际作用，不再赘述  </p>
<p>我们继续往下看，还记得之前我们通过不停的调用<code>_import-node</code>与<code>_import-nodes-inner</code>与<code>get-inherited-nodes</code>函数构建了所有有继承关系的makefile自己的变量的值的关系，所以我们在这里展开的时候，直接将<code>@inherit:last_makefile</code>替换为<code>PRODUCT.last_makefile.PRODUCT_xxx</code>的值，这里就简单的展开结束，因此我们最后得到就是所有继承变量的综合起来的内容  </p>
<h3 id="检查所有的product"><a href="#检查所有的product" class="headerlink" title="检查所有的product"></a>检查所有的product</h3><p>最后还剩下一点简单的代码，是用来解析出一个short-name后边来使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># Sanity check</span><br><span class="line">$(check-all-products)</span><br><span class="line"></span><br><span class="line">ifneq ($(filter dump-products, $(MAKECMDGOALS)),)</span><br><span class="line">$(dump-products)</span><br><span class="line">$(error done)</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line"># Convert a short name like &quot;sooner&quot; into the path to the product</span><br><span class="line"># file defining that product.</span><br><span class="line">#</span><br><span class="line">INTERNAL_PRODUCT := $(call resolve-short-product-name, $(TARGET_PRODUCT))</span><br><span class="line">ifneq ($(current_product_makefile),$(INTERNAL_PRODUCT))</span><br><span class="line">$(error PRODUCT_NAME inconsistent in $(current_product_makefile) and $(INTERNAL_PRODUCT))</span><br><span class="line">endif</span><br></pre></td></tr></table></figure>
<p>首先，<code>check-all-products</code>来检查全部products</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">define check-all-products</span><br><span class="line">$(if ,, \</span><br><span class="line">  $(eval _cap_names :=) \</span><br><span class="line">  $(foreach p,$(PRODUCTS), \</span><br><span class="line">    $(eval pn := $(strip $(PRODUCTS.$(p).PRODUCT_NAME))) \</span><br><span class="line">    $(if $(pn),,$(error $(p): PRODUCT_NAME must be defined.)) \</span><br><span class="line">    $(if $(filter $(pn),$(_cap_names)), \</span><br><span class="line">      $(error $(p): PRODUCT_NAME must be unique; &quot;$(pn)&quot; already used by $(strip \</span><br><span class="line">          $(foreach \</span><br><span class="line">            pp,$(PRODUCTS),</span><br><span class="line">              $(if $(filter $(pn),$(PRODUCTS.$(pp).PRODUCT_NAME)), \</span><br><span class="line">                $(pp) \</span><br><span class="line">               ))) \</span><br><span class="line">       ) \</span><br><span class="line">     ) \</span><br><span class="line">    $(eval _cap_names += $(pn)) \</span><br><span class="line">    $(if $(call is-c-identifier,$(pn)),, \</span><br><span class="line">      $(error $(p): PRODUCT_NAME must be a valid C identifier, not &quot;$(pn)&quot;) \</span><br><span class="line">     ) \</span><br><span class="line">    $(eval pb := $(strip $(PRODUCTS.$(p).PRODUCT_BRAND))) \</span><br><span class="line">    $(if $(pb),,$(error $(p): PRODUCT_BRAND must be defined.)) \</span><br><span class="line">    $(foreach cf,$(strip $(PRODUCTS.$(p).PRODUCT_COPY_FILES)), \</span><br><span class="line">      $(if $(filter 2 3,$(words $(subst :,$(space),$(cf)))),, \</span><br><span class="line">        $(error $(p): malformed COPY_FILE &quot;$(cf)&quot;) \</span><br><span class="line">       ) \</span><br><span class="line">     ) \</span><br><span class="line">   ) \</span><br><span class="line">)</span><br><span class="line">endef</span><br></pre></td></tr></table></figure>


<p>这里简单调用了<code>resolve-short-product-name</code>的函数，然后将参数传入<code>_resolve-short-product-name</code>，我们直接来看</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">define _resolve-short-product-name</span><br><span class="line">  $(eval pn := $(strip $(1)))</span><br><span class="line">  $(eval p := \</span><br><span class="line">      $(foreach p,$(PRODUCTS), \</span><br><span class="line">          $(if $(filter $(pn),$(PRODUCTS.$(p).PRODUCT_NAME)), \</span><br><span class="line">            $(p) \</span><br><span class="line">       )) \</span><br><span class="line">   )</span><br><span class="line">  $(eval p := $(sort $(p)))</span><br><span class="line">  $(if $(filter 1,$(words $(p))), \</span><br><span class="line">    $(p), \</span><br><span class="line">    $(if $(filter 0,$(words $(p))), \</span><br><span class="line">      $(error No matches for product &quot;$(pn)&quot;), \</span><br><span class="line">      $(error Product &quot;$(pn)&quot; ambiguous: matches $(p)) \</span><br><span class="line">    ) \</span><br><span class="line">  )</span><br><span class="line">endef</span><br><span class="line">define resolve-short-product-name</span><br><span class="line">$(strip $(call _resolve-short-product-name,$(1)))</span><br><span class="line">endef</span><br></pre></td></tr></table></figure>

<p>以上代码也很简单，就是针对对应的product_makefile来获取对应的PRODUCT_NAME，然后定义为短product_name</p>
<p>至此，我们关于AndroidProduct.mk文件的关键点的解析已经完成．</p>
</div><div class="article-licensing box"><div class="licensing-title"><p>Android编译系统分析之几个关键点（一）</p><p><a href="http://www.0xforee.top/2015/12/22/android-build-system-keypoint-first/">http://www.0xforee.top/2015/12/22/android-build-system-keypoint-first/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>0xforee</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2015-12-22</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2015-12-22</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/android/">android</a><a class="link-muted mr-2" rel="tag" href="/tags/build/">build</a><a class="link-muted mr-2" rel="tag" href="/tags/makefile/">makefile</a></div><div class="article-tags is-size-7 mb-4"> <emoji-reaction availableArrayString="👍,thumbs-up;😄,smile-face;🎉,party-popper;😕,confused-face;❤️,red-heart;🚀,rocket;👀,eyes;"></emoji-reaction> </div><div class="a2a_kit a2a_kit_size_32 a2a_default_style"><i class="fas fa-share-nodes fa-2xl" style="float:left;margin-right: 10px;"></i><a class="a2a_dd" target="_blank" rel="noopener" href="https://www.addtoany.com/share"></a><a class="a2a_button_wechat"></a><a class="a2a_button_telegram"></a><a class="a2a_button_evernote"></a><a class="a2a_button_pocket"></a><a class="a2a_button_flipboard"></a><a class="a2a_button_douban"></a><a class="a2a_button_instapaper"></a><a class="a2a_button_kindle_it"></a><a class="a2a_button_email"></a><a class="a2a_button_copy_link"></a><i class="fa-light fa-share"></i></div><script async src="https://static.addtoany.com/menu/page.js"></script><script src="https://static.addtoany.com/menu/page.js" defer></script></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="/img/alipay.jpg" alt="支付宝"></span></a><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="/img/wechat.jpg" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2015/12/28/android-build-system-keypoint-second/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Android编译系统分析之几个关键点（二）</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2015/12/08/android-build-system-make/"><span class="level-item">Android编译系统分析之make分析</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div class="content" id="valine-thread"></div><script src="//cdn.jsdelivr.net/npm/leancloud-storage@3/dist/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine@1.4.16/dist/Valine.min.js"></script><script>new Valine({
            el: '#valine-thread',
            appId: "syj6F1Y9iqTJ7vzM2sniKUYz-gzGzoHsz",
            appKey: "Ox2jK9gEuEEsz0gyfOiCSf8P",
            placeholder: "gogo",
            avatar: "mm",
            avatarForce: false,
            meta: ["nick","mail","link"],
            pageSize: 10,
            lang: "zh-CN",
            visitor: false,
            highlight: true,
            recordIP: false,
            
            
            
            enableQQ: false,
            requiredFields: [],
        });</script></div></div></div><!--!--><div class="column column-right is-3-tablet is-3-desktop is-3-widescreen  order-3"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/img/head.png" alt="0xforee"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">0xforee</p><p class="is-size-6 is-block">Read The Fuck Code</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Earth</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">29</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">栏目</p><a href="/categories"><p class="title">10</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">39</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/0xforee" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/0xforee"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="JueJin" href="https://juejin.cn/user/2518350422615987"><i class="fas fa-j"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="CSDN" href="https://blog.csdn.net/beijing2008lm?type=blog"><i class="fas fa-c"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Mail" href="mailto:0xforee@gmail.com"><i class="fas fa-envelope"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-08-17T18:23:34.000Z">2023-08-18</time></p><p class="title"><a href="/2023/08/18/lifecycle-i-of-glide-code-design/">从代码设计看 Glide 之生命周期（上）</a></p><p class="categories"><a href="/categories/Glide/">Glide</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-08-15T14:32:03.000Z">2023-08-15</time></p><p class="title"><a href="/2023/08/15/upgrade-my-site-config/">【公告】站点升级&amp;域名切换</a></p><p class="categories"><a href="/categories/Other/">Other</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-08-11T14:06:00.000Z">2023-08-11</time></p><p class="title"><a href="/2023/08/11/core_of_glide_code_design/">从代码设计看 Glide 之核心功能</a></p><p class="categories"><a href="/categories/Glide/">Glide</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-08-01T14:51:07.000Z">2023-08-01</time></p><p class="title"><a href="/2023/08/01/how-to-use-kotlin-coroutine/">一文帮你快速理解协程使用模型</a></p><p class="categories"><a href="/categories/kotlin/">kotlin</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-07-02T15:57:00.000Z">2023-07-02</time></p><p class="title"><a href="/2023/07/02/begging_of_glide_code_design/">从代码设计看 Glide 之写在开头</a></p><p class="categories"><a href="/categories/Glide/">Glide</a></p></div></article></div></div><div class="card widget is-sticky" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#该加载哪里的AndroidProducts-mk文件？"><span class="level-left"><span class="level-item">1</span><span class="level-item">该加载哪里的AndroidProducts.mk文件？</span></span></a></li><li><a class="level is-mobile" href="#取得编译系统中所有的AndroidProducts-mk"><span class="level-left"><span class="level-item">2</span><span class="level-item">取得编译系统中所有的AndroidProducts.mk</span></span></a></li><li><a class="level is-mobile" href="#取得current-makefile（当前lunch机型的配置文件）"><span class="level-left"><span class="level-item">3</span><span class="level-item">取得current_makefile（当前lunch机型的配置文件）</span></span></a></li><li><a class="level is-mobile" href="#导入PRODUCT变量"><span class="level-left"><span class="level-item">4</span><span class="level-item">导入PRODUCT变量</span></span></a></li><li><a class="level is-mobile" href="#什么是inherit？"><span class="level-left"><span class="level-item">5</span><span class="level-item">什么是inherit？</span></span></a></li><li><a class="level is-mobile" href="#展开继承的变量"><span class="level-left"><span class="level-item">6</span><span class="level-item">展开继承的变量</span></span></a></li><li><a class="level is-mobile" href="#检查所有的product"><span class="level-left"><span class="level-item">7</span><span class="level-item">检查所有的product</span></span></a></li></ul></div></div><script src="/js/toc.js" defer></script></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/">0xforee&#039;s blog</a><p class="is-size-7"><span>&copy; 2023 0xforee</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv"><span id="busuanzi_value_site_pv">0</span>次访问</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><script type="module" src="https://cdn.jsdelivr.net/gh/emaction/frontend.dist@1.0.9/bundle.js"></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"栏目","tags":"标签"});
        });</script></body></html>